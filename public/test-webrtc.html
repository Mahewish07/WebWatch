<!DOCTYPE html>
<html>
<head>
    <title>üß™ WebRTC Test - WebWatch</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1a1a; color: white; }
        .container { max-width: 800px; margin: 0 auto; }
        video { width: 300px; height: 200px; border: 2px solid #333; margin: 10px; background: #000; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; background: #333; }
        .success { background: #28a745; }
        .error { background: #dc3545; }
        .info { background: #17a2b8; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ WebRTC Test - WebWatch</h1>
        <p>Test camera access and WebRTC functionality</p>
        
        <div>
            <button onclick="startCamera()">üìπ Start Camera</button>
            <button onclick="stopCamera()">‚èπÔ∏è Stop Camera</button>
            <button onclick="testConnection()">üîÑ Test WebRTC</button>
        </div>
        
        <div id="status" class="status">Click "Start Camera" to begin</div>
        
        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
            <div>
                <h3>Local Video (Your Camera)</h3>
                <video id="localVideo" autoplay playsinline muted></video>
            </div>
            <div>
                <h3>Remote Video (Simulated)</h3>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
        
        <div>
            <h3>Debug Console</h3>
            <pre id="debugLog" style="background: #000; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto;"></pre>
        </div>
    </div>

    <script>
        let localStream = null;
        let peerConnection = null;
        
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');
        const debugLog = document.getElementById('debugLog');
        
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        function log(message) {
            console.log(message);
            debugLog.textContent += new Date().toLocaleTimeString() + ': ' + message + '\n';
            debugLog.scrollTop = debugLog.scrollHeight;
        }
        
        function updateStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            log(message);
        }
        
        async function startCamera() {
            try {
                updateStatus('üîÑ Requesting camera access...', 'info');
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                localVideo.srcObject = localStream;
                updateStatus('‚úÖ Camera started successfully!', 'success');
                
                log(`Camera tracks: ${localStream.getVideoTracks().length}`);
                log(`Video track label: ${localStream.getVideoTracks()[0]?.label}`);
                
            } catch (error) {
                updateStatus(`‚ùå Camera error: ${error.message}`, 'error');
                log(`Camera error: ${error.name} - ${error.message}`);
            }
        }
        
        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                updateStatus('‚èπÔ∏è Camera stopped', 'info');
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                remoteVideo.srcObject = null;
            }
        }
        
        async function testConnection() {
            if (!localStream) {
                updateStatus('‚ùå Start camera first!', 'error');
                return;
            }
            
            try {
                updateStatus('üîÑ Testing WebRTC connection...', 'info');
                
                // Create peer connection
                peerConnection = new RTCPeerConnection(rtcConfig);
                
                // Add local stream
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    log(`Added track: ${track.kind}`);
                });
                
                // Handle remote stream
                peerConnection.ontrack = (event) => {
                    log('üì® Received remote stream');
                    remoteVideo.srcObject = event.streams[0];
                    updateStatus('‚úÖ WebRTC connection successful!', 'success');
                };
                
                // Monitor connection state
                peerConnection.onconnectionstatechange = () => {
                    log(`Connection state: ${peerConnection.connectionState}`);
                };
                
                peerConnection.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${peerConnection.iceConnectionState}`);
                };
                
                // Create offer and answer (simulate peer-to-peer)
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('Offer created and set as local description');
                
                // Simulate remote peer accepting offer
                await peerConnection.setRemoteDescription(offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                log('Answer created and connection established');
                
                updateStatus('üîÑ WebRTC test completed', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå WebRTC error: ${error.message}`, 'error');
                log(`WebRTC error: ${error.name} - ${error.message}`);
            }
        }
        
        // Auto-detect capabilities on load
        window.addEventListener('load', () => {
            log('=== WebRTC Capability Test ===');
            log(`getUserMedia: ${!!navigator.mediaDevices?.getUserMedia}`);
            log(`RTCPeerConnection: ${!!window.RTCPeerConnection}`);
            log(`HTTPS: ${location.protocol === 'https:'}`);
            log(`User Agent: ${navigator.userAgent}`);
            
            if (location.protocol !== 'https:') {
                updateStatus('‚ö†Ô∏è HTTPS required for camera access', 'error');
            } else if (!window.RTCPeerConnection) {
                updateStatus('‚ùå WebRTC not supported', 'error');
            } else {
                updateStatus('‚úÖ Browser supports WebRTC', 'success');
            }
        });
    </script>
</body>
</html>